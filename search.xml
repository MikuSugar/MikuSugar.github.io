<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用Zig辅助RUST进行跨平台交叉编译]]></title>
    <url>%2F2025%2F09%2F19%2FRust_ZigBuild%2F</url>
    <content type="text"><![CDATA[用Zig辅助RUST进行跨平台交叉编译用Zig辅助RUST进行跨平台交叉编译缘起利用rust写的项目需要在mips64el环境下运行，并且该环境的glibc版本非常低，调研了各种方法后发现用Zig最为方便。 rust可以通过cargo-zigbuild工具利用zig的工具链方便的跨平台交叉编译，并且支持指定glibc版本。本文简单介绍使用方法。下面描述将环境分为构建机和运行机，构建机为构建打包的机器环境，运行机为程序的最终运行环境。 &nbsp; 构建机环境准备1.安装Rust开发环境1curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 参考：https://www.rust-lang.org/tools/install 2.安装Zig环境以mac为例： 1brew install zig 其它系统参考：https://ziglang.org/download/ 3.安装cargo-zigbuild1cargo install cargo-zigbuild 打包命令参考1.获取运行机环境glibc版本1ldd --version 2.构建机打包简单分为两种情况，一种是Rust官方有现成的std包，例如aarch64-linux。一种是Rust官方没有现成的std包，例如mips64el-linux，下面分别介绍这两种情况的例子 如果打包aarch64-linux 1234# 下载官方的std包rustup target add aarch64-unknown-linux-gnu# 打包，下面的aarch64-unknown-linux-gnu.2.25最后的2.25指定的是glibc版本号cargo zigbuild --target aarch64-unknown-linux-gnu.2.25 --release 如果打包mips64el-linux 1234567# 标准库源码安装rustup component add rust-src --toolchain nightly## 对于mac-arm,标准库源码安装是rustup component add rust-src --toolchain nightly-aarch64-apple-darwin# 编译打包，下面的mips64el-unknown-linux-gnuabi64.2.25 最后的2.25指定的是glibc版本号cargo +nightly zigbuild --target mips64el-unknown-linux-gnuabi64.2.25 --release -Z build-std=core,alloc,std,proc_macro]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[首次半马&&2024年十二月运动记录]]></title>
    <url>%2F2025%2F01%2F01%2F202412_Sport%2F</url>
    <content type="text"><![CDATA[运动记录最后一个月我的运动主要是跑步，跑了122公里，在这个月先突破了15公里，后面在2024年最后一天跑了半程马拉松。&nbsp; 首次半程马拉松在2024年最后一天想做点什么来纪念一下，我选择了尝试跑一下半马，我的正常极限大概是16km，在16km处我感觉我的腿出现痛觉了，后半程我一路在自己对自己喊着加油，在快到终点的时候，前方正好有人在放烟花，眼泪突然流出来，我不知道我是高兴还是难受。 跑到21.1km的时候我停下来了，一种我从来没有体验过的快乐，极致的快乐突然向我袭来，我在跑道上边走边大笑，远处还有烟花升空炸裂的声音。我感觉我的脑子变的非常非常清醒，我很想和人分享我现在的快乐，感觉特别特别快乐，我给兄弟群发了一个大红包和我的兄弟分享我的喜悦，我又去公司锻炼群发了一个红包分享我的喜悦。。。 这种喜悦一直持续到深夜，我失眠了，也许是运动过后皮质醇太高导致我睡不着，也许是我太兴奋了，我感觉我的大脑非常的清醒，不断闪现各种人做出的行为，又不断闪现各种人之前的一些行为细节，我仿佛看透了他们的心理，仿佛知道了他们做出行为的动机。接着我又突然陷入了愤怒，这种愤怒很奇怪，我开始审视它，它又消失，接着巨大的悲伤向我袭过来，也许是要平衡之前的快乐情绪。。。过了一段时间快乐又向我袭来。 我的情绪就这样一直在快乐、悲伤之间来回切换，直到刚刚才突然感觉特别特别的疲惫，写完这些我就去睡觉了。 不知道明天的我是什么样的]]></content>
      <tags>
        <tag>跑步</tag>
        <tag>马拉松</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年十一月运动记录]]></title>
    <url>%2F2024%2F12%2F01%2F202411_Sport%2F</url>
    <content type="text"><![CDATA[十一月的运动只有跑步，跑了一百三十多公里，刷新了单次最长跑步距离，11.36公里。（因为天气太冷了，走回住处太冷了，选择跑回去。。。）后面买了冬季跑步运动套装，跑步不冷了。&nbsp; 天气太冷了，早上没法早起了，几乎都是夜跑。]]></content>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年九月和十月运动记录]]></title>
    <url>%2F2024%2F11%2F03%2F202409_and_10_Sport%2F</url>
    <content type="text"><![CDATA[九月的运动主要是跑步、骑行和徒步，十月的运动主要是跑步。&nbsp; 跑步九月份跑了70公里。 十月份跑了124公里。 在十月份的时候我通过running_page这个项目搭建了自己的跑步主页，希望可以一直坚持跑下去。 骑行十月份没有骑行，九月份和朋友一起二刷了天府绿道。 徒步九月份徒步了黄龙、九寨沟、折多山。高海拔徒步真难顶，尤其是黄龙和折多山。]]></content>
      <tags>
        <tag>跑步</tag>
        <tag>骑行</tag>
        <tag>徒步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年八月运动记录-月跑量破一百二公里]]></title>
    <url>%2F2024%2F09%2F05%2F202408_Sport%2F</url>
    <content type="text"><![CDATA[八月的运动主要是跑步，月跑量突破了120公里，骑行只骑行了四十多公里。&nbsp; 跑步八月的跑步突破了120公里，配速稳定在6分配。这个月天气太热了，由夜跑换成了晨跑。 跑步与冥想最近冥想做的比较少，跑步进入状态以后和冥想进入状态给我的感觉差不多，就是完全的放空，我很喜欢这种感觉，和跑步结束后带来的愉快感不太一样，放空的时候感觉不到累，啥都感觉不到一样，不知不觉就跑完了。 跑步拍的照片 骑行这个月骑行比较少，因为通勤没有骑车了。]]></content>
      <tags>
        <tag>跑步</tag>
        <tag>骑行</tag>
        <tag>冥想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年7月运动记录]]></title>
    <url>%2F2024%2F08%2F01%2F202407_Sport%2F</url>
    <content type="text"><![CDATA[七月的运动依然集中在跑步和骑行，跑步跑了八十多公里，骑行了两百多公里。 &nbsp; 跑步跑步最大的进步是配速破七了，进入入门阶段了。 下面放一些跑步期间拍的照片 骑行这个月除了一次骑车从成都去眉山，其余的都是通勤骑行。 一些照片。（天府大道真的笔直，上坡好累，下坡好爽]]></content>
      <tags>
        <tag>跑步</tag>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年6月运动记录]]></title>
    <url>%2F2024%2F07%2F01%2F202406_Sport%2F</url>
    <content type="text"><![CDATA[六月的运动主要集中在跑步和骑行。&nbsp; 跑步这个月跑了75公里，慢慢把配速拉上去了。最快的配速也终于5公里破七了。 骑行这个月骑了312公里。 除了日常通勤以外，骑行了两次比较长的。 深圳骑行去海边和朋友一起骑行的 成都绕城绿道一个人骑行的，从早上骑到下午，包括住的地方到绿道，总共135公里。 买的第一辆山地车 路边的小吃 午饭，凉面 路边的野花]]></content>
      <tags>
        <tag>跑步</tag>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入冥想]]></title>
    <url>%2F2024%2F06%2F06%2F%E5%88%9D%E5%85%A5%E5%86%A5%E6%83%B3%2F</url>
    <content type="text"><![CDATA[缘起前段时间为了让自己平静下来，开始尝试冥想，我所使用的方法是正念冥想，简单的所就是坐端正，闭上眼睛，用鼻子呼吸，数呼吸。参考了conge写的 blog。 感受第一次冥想了10分钟，睁眼之后感觉非常平静。冥想过程中能感受到非常多的念头，不需要去管他们，把注意力拉回呼吸，那些念头会自己消散，有的时候观察念头的升起和消散也很有趣。不过，不是很建议长时间冥想，当我的时间超过15-20分钟后，便会出现一些意料之外的感受，下面说说遇到的一些情况： 我突然感觉有人在抱着我，触感非常真实 突然感觉看到大海，念头就像一个一个气泡从海上升起，然后又破裂，我观察这些念头，突然看到一个泡泡在海平面上不上升，海底有巨大的阴影，我尝试观察，心率开始加快，冥想终止，可能这是我的心结吧 突然看到恶佛的头 听到清晰的标准播音腔在说话，但是听不清内容 现在我不再尝试冥想超过15分钟。 现在冥想大概也尝试了快一个月了，我发现我越来越与自己有一种抽离感？看到念头的时候感觉像是他人的念头一样，我作为一个旁观者观察我。我不知道这种状态是好还是坏，不过让我越来越平静，我感觉我像是在玩游戏一样，我在操控我自己，比如我最近在跑步，很容易就坚持下来，因为我想给自己加身体的属性值，我就像游戏一样操控自己去跑步。]]></content>
      <tags>
        <tag>冥想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与chatgpt扮演的苏哥拉底讨论独立]]></title>
    <url>%2F2024%2F06%2F01%2F%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E6%8E%A2%E8%AE%A8%E7%8B%AC%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[突然想到之前在《刺客信条 奥德赛》中苏哥拉底的任务，试试和gpt扮演的苏哥拉底对话 对话内容 我:请你扮演苏格拉底和我对话 ChatGPT:当然，我很乐意扮演苏格拉底。让我们开始这场对话吧。你可以从任何问题或主题开始。 你有什么问题想要讨论或探讨的吗？ 我:人如何才是独立的&nbsp; ChatGPT:这是一个很深刻的问题。为了探讨这个问题，让我们先从一些基本的定义开始。你如何定义“独立”呢？独立对于你意味着什么？ 我:我认为人独立分为物质独立和精神独立，物质独立是能独立自给自足，精神独立是不依赖他人，我之前认为人独立主要是物质独立，但是现在我依赖的人离开了我，我感觉痛苦ChatGPT:你的定义很有见地。你提到了物质独立和精神独立，这是非常重要的区分。让我们逐步探讨这些概念。 首先，关于物质独立。你提到这是指一个人能够自给自足。你认为一个人在物质上完全自给自足是否足够让他感到真正独立？ 其次，关于精神独立。你提到这是指不依赖他人。你是否认为真正的精神独立意味着完全不需要他人的支持或陪伴？或者，精神独立是否可能包含一种健康的关系和相互依赖？ 最后，你提到当依赖的人离开时，你感到痛苦。你认为这种痛苦是否揭示了独立的另一个层面？也许独立并不仅仅是自给自足或不依赖他人，而是如何在失去依赖时重新找到自己的平衡和力量。 你怎么看这些问题？ 我:物质的独立无法感到独立，我认为精神独立是完全不依赖他人，最后一个问题我不知道ChatGPT:你的思考很深刻。让我们继续探讨这些观点。 首先，你提到物质的独立无法带来真正的独立。这表明你意识到物质上的自给自足并不足以满足人的全部需求。人的需求不仅仅是物质上的，还有心理和情感上的。 关于精神独立，你认为这是完全不依赖他人。这是一个很高的标准。让我们进一步探讨：如果一个人完全不依赖他人，他是否还能体验到人际关系中的支持、爱和关怀？这种完全的独立是否可能导致孤立？ 最后一个问题涉及到你在失去依赖时感到的痛苦。这种痛苦或许揭示了人的一种本质——我们是社会性动物，需要与他人建立联系和关系。精神独立可能并不是完全不依赖他人，而是能够在依赖关系发生变化时，找到内在的力量和稳定感。 让我们思考一下：精神独立是否可以理解为一种内在的平衡和自信，无论外界环境如何变化？这种独立是否意味着你可以在需要时寻求支持，但在支持消失时，仍然能够保持内心的平静和力量？ 你怎么看这种理解？ 我:我认为就算独立也应该能感受到他人的爱和关怀，你说的对，精神独立重要的是在任何情景下都能保持稳定和平静ChatGPT:你的思考非常深刻。我也同意，独立并不意味着拒绝他人的爱和关怀。相反，真正的精神独立可能意味着在接受他人支持的同时，仍然能够保持内心的稳定和平静。 让我们进一步探讨精神独立的内涵。或许我们可以通过以下几个问题来加深理解： 内在力量：精神独立是否意味着拥有一种内在的力量，使我们能够在面对困境和挑战时，不轻易被外界的变化所动摇？自我认知：你认为了解自己、接受自己、不因他人的评价而改变自己的价值观和行为，是精神独立的重要组成部分吗？情感管理：精神独立是否包括能够有效地管理自己的情感，在失去依赖时找到自我安慰和支持的方法？关系的平衡：你认为精神独立与人际关系之间如何平衡？如何在依赖他人和保持自我之间找到平衡？你的见解已经表明你对精神独立有了深刻的理解。或许我们可以通过这些问题进一步探讨，找出更多具体的方法来实现和保持这种精神独立。 你怎么看这些问题？或者你有其他具体的问题或困惑希望探讨吗？ 我:内在力量，我认为可能需要相信自己，自我认知应该是重要组成部分，我现在会自我怀疑，情感管理是需要平静，我现在使用的方法是冥想和跑步，关系的平衡我认为是不要干涉他人的选择？ChatGPT:你的观点非常清晰，让我们深入探讨每一个方面： 内在力量和自我信念： 你提到相信自己，这是内在力量的核心。你认为有哪些具体的方法可以增强自己的信心和内在力量？例如，设定小目标并逐步实现、记录自己的成就等。自我认知： 自我认知确实是精神独立的重要组成部分。你提到会自我怀疑，或许可以通过反思和自我对话来缓解这种怀疑。你是否有尝试过写日记或者与值得信赖的朋友交流，来更好地认识和接纳自己？情感管理： 你使用冥想和跑步来平静情绪，这是很好的方法。你认为还有哪些活动或练习可以帮助你更好地管理情感，比如艺术创作、阅读、或者其他你感兴趣的活动？关系的平衡： 你提到不干涉他人的选择，这是一个重要的原则。你认为在不干涉他人的同时，如何表达你的关心和支持？比如，通过倾听和理解对方，而不是试图改变他们的决定。你已经展示了很多智慧和自我反思的能力。或许我们可以进一步探讨每一个方面，找出更多具体的方法来增强你的精神独立性。 你怎么看这些建议？有没有特别想深入探讨的某个方面？ 我:我想探讨自我认知和关系的平衡ChatGPT:当然，我们可以深入探讨自我认知和关系的平衡。 自我认知自我反思： 写日记：每天花几分钟写下当天的经历、感受和思考，可以帮助你更好地了解自己。这不仅能记录下你的进步，还能帮助你发现一些可能平时忽略的内在情感和想法。自我对话：与自己进行对话，问自己一些深层次的问题，比如：“我真正想要的是什么？”“我目前的行动是否符合我的价值观？”这样可以帮助你更清晰地认识自己。反馈与倾听： 寻求反馈：与值得信赖的朋友或家人交流，听取他们对你的看法和建议，这有助于你看到自己可能忽略的优点和需要改进的地方。倾听自己：在做决定时，倾听内心的声音，信任自己的直觉，不要被外界的噪音干扰。接受和包容： 接受自己的不完美：每个人都有优点和缺点，接受自己的不完美并不代表放弃改进，而是以更健康的心态面对自己。自我包容：对自己宽容，不因为一时的错误或失败而过于自责，学会从中吸取教训，继续前进。关系的平衡尊重他人的选择： 不干涉他人：尊重他人的决定和选择，即使这些决定与你的期望不同。每个人都有权利选择自己的生活道路。界限设置：明确自己的界限，不让他人的选择和行为过多地影响你的情绪和决定。表达关心和支持： 有效沟通：学会倾听和表达自己的感受。在对话中，使用“我”开头的句子，如“我感到……”，而不是直接评价对方的行为。非侵入性支持：在提供帮助时，先询问对方的需求，如“你需要我的帮助吗？”这样可以避免在对方不需要时强加帮助。共存与独立： 保持自我：在关系中，保持自己的兴趣爱好和独立空间，这样既能维持个人的独立性，也能为关系注入新的活力。共同成长：鼓励和支持对方的成长，同时也关注自己的成长，保持一种平衡的关系动态。你认为这些建议对你有帮助吗？或者你有具体的情况或问题希望进一步探讨？ 我:我太久不是一个人生活了，我有点忘记了一个人是怎么生活了ChatGPT:独自生活可能会感觉陌生甚至有些孤单，但它也是一个重新认识自己、培养独立性的机会。让我们具体探讨一些方法，帮助你重新适应独自生活并找到其中的乐趣和意义。 重新适应独自生活建立日常习惯： 制定规律的作息时间：保持规律的睡眠和饮食习惯，这能帮助你保持身体健康和精神稳定。安排每天的计划：列出每天要做的事情，包括工作、学习、锻炼、休闲等，这能让你的生活有条理且富有意义。培养兴趣爱好： 探索新爱好：尝试一些你一直想做但没有时间或机会尝试的活动，如绘画、摄影、烹饪、音乐等。参与社交活动：虽然独自生活，但不意味着要完全孤立自己，可以参加一些社交活动或兴趣小组，结识新朋友。注重自我关怀： 冥想和放松：继续进行冥想和跑步，这些活动不仅有助于身体健康，也能帮助你管理情绪，保持内心平静。自我奖励：在完成一些目标或任务后，给自己一些奖励，如看一部喜欢的电影，或者做一顿美味的饭菜。反思与成长： 记录心情和感受：每天写日记，记录下你的心情、感受和反思，帮助你更好地理解和调整自己。设定成长目标：给自己设定一些短期和长期的目标，无论是职业上的，还是个人发展的，这能让你有动力和方向感。享受独自生活的好处自由与自主： 时间自由：你可以完全根据自己的节奏和喜好安排时间，不受他人干扰。自主决策：所有的决定都由你自己做主，这能增强你的决策能力和自信心。内在成长： 自我探索：独自生活是深入了解自己的好机会，你可以更清晰地认识到自己的需求、喜好和目标。独立性增强：通过独自处理生活中的各种事务，你会变得更加独立和坚强。灵活性和适应力： 适应变化：独自生活能提高你的适应能力，面对变化时更加从容和有韧性。灵活安排：你可以根据自己的情况灵活安排生活，不需要考虑他人的时间和需求。你认为这些建议能帮助你重新适应和享受独自生活吗？或者你有具体的挑战或疑问希望进一步探讨？ 我:谢谢你，现在很晚了，我们下次再聊ChatGPT:好的，很高兴能和你进行这次有意义的对话。希望这些建议对你有所帮助。祝你晚安，我们下次再聊！]]></content>
      <tags>
        <tag>杂思</tag>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024年5月跑步记录]]></title>
    <url>%2F2024%2F06%2F01%2F202405_run%2F</url>
    <content type="text"><![CDATA[5月总共跑了31公里，5月14号开始跑的。 很久没有跑步了，跑步会让我有种活着的感觉，尤其是我第一次挑战10公里的时候，我没有想到我真的能做到，跑的时候我就想着，到下一个路灯，到下一个路灯，就这样一路跑了10公里，最后停下的时候我感觉整个人都要升天了一样，头脑感觉特别放松。]]></content>
      <tags>
        <tag>跑步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西藏之旅]]></title>
    <url>%2F2024%2F05%2F17%2F%E8%A5%BF%E8%97%8F%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[序西藏，一直很想去看看，记得高中毕业的时候就想坐火车去拉萨看看，但是爸妈不让，估计是为了安全。最近在翻以前写的备忘录，看到六年前列了个单子，里面有很多想去的地方，后面还跟着很多备注，这么多年过去了，备注我都忘记是啥意思，当时用的字母缩写备注，这些地方中就有拉萨，查了查火车票，正好有一趟周五晚上出发，周日早上到，这样我周日晚上再做飞机回来上班，周末特种兵游。 &nbsp; 启程礼拜五下午的时候我在想，我这样做是为了什么，感觉像是在逃避现实，我和朋友聊了聊，朋友说，快乐最重要，管它是不是逃避现实。 晚上出发去火车站，18号线-&gt;9号线，正好是我一年多以前下班的路线，我在地铁上发呆，我依然在我一年多以前经常坐的那个车厢，我看到了以前的我，我在想如果他知道了现在的我，会怎么想，都不一样了，他那时候怎么也想不到现在的我吧，我好想拍拍那个一身黑的我。 到了车站，活力仿佛又回来了，我喜欢这种在路上的感觉，我喜欢火车路上摇摇晃晃，轰隆轰隆的声音，这可能让我感觉我还在前进吧。 路上我坐的是Z322次列车，从成都西出发，经停兰州、西宁、德令哈、格尔木，终到拉萨。 兰州从成都西到兰州路上我是痛苦的，尤其是在兰州停止的时候，感觉整个人都是懵的，甚至想下车去，我为了防止我失去控制，我在社交平台上直接说自己要去拉萨。离开兰州快到西宁这段我现在印象中很模糊了，只记得非常难受，可能是大脑为了保护，现在已经回忆不起痛苦的细节了。 西宁到了西宁，要换高原供氧车型了，我的心情开始好转，我和同车的大叔一起去擦车窗的玻璃，这仿佛是青藏铁路的仪式一样。 从西宁出发之后，我看到了青海湖，可惜草还没有长绿，如果长绿了，那应该很美很美。 看到了一朵奇怪的云。 后面草变绿了一些，还有咩咩 看到了远方的雪山 德令哈到德令哈了，对德令哈最初的印象来自于海子的那首诗。 几乎都是戈壁 格尔木到格尔木站了，换了内燃机火车头，接下来要穿越可可西里，翻过唐古拉山。 先是戈壁，后面开始出现了雪山。 雪山越来越近 后面来到了可可西里 唐古拉山的梦翻唐古拉山的时候我做了一个梦，梦里面一只很像猫的动物在叫我，我挥挥手，它歪着头看着我，后面走了，我去追，追不上，然后醒了，头非常非常的晕，我大概是高反了，吃了一份葡萄糖补剂后好了一点，手表显示血氧在74%，海拔在五千多，整个头脑非常的昏昏沉沉，后面又睡着了，我又突然梦见了太阳升起来，把整个车厢照的非常亮，太阳非常非常大，我准备拿手机拍下来，我突然醒了，整个车厢一片漆黑 兰州之后我并不太能记得兰州之后的心理，我几乎全程都在走廊的窗户上发呆，我听了很长时间《空帆船》 我一直看着窗户外面，我想了很多很多，但是我现在一点也不记得我想了什么，可能是高反让我的记忆缺失了？我逐渐被不断出现的景色转移了注意力，我很想去看雪山，但是我一直没有机会去看，现实中见到雪山和在视频里看到的感觉是完全不一样的，太震撼了（青藏铁路真他妈牛逼），我显得很渺小，我目不转睛的看着一座又一座的雪山，我忘记了我的想法，我忘记了时间，我后悔当时没有记录下自己的想法，我现在想不起来了，可能海拔越高，脑子缺氧，没保存下来。 拉萨在拉萨的时候早上发现大部分都是川菜馆，找了好久在布达拉宫旁边找到一家藏式早餐店，酥油茶5块钱，油饼2块钱，物价比我想象中便宜一点。 后面去爬了布达拉宫，花了200块钱门票，感觉里面并不好看，西藏这么贫瘠的地方，里面的和尚却用了那么多珠宝黄金。。。西藏能净化心灵的是缺氧和风景，缺氧的时候脑子什么也想不了，我现在还挺想回到那种状态。 早知道直接在广场看看就去看自然风景好了。 回程在飞机上一路几乎都可以看到雪山🏔️]]></content>
      <tags>
        <tag>游历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[痛苦记录1]]></title>
    <url>%2F2024%2F05%2F17%2F%E7%97%9B%E8%8B%A6%E8%AE%B0%E5%BD%951%2F</url>
    <content type="text"><![CDATA[记录下痛苦，或许有帮助渡过痛苦 开始痛苦开始很突然，突然由过去的记忆开始 身体感受 胸部心脏位置发闷 感觉憋着一口气 会想抓头 会想弄痛身体转移注意力 头轻微的痛 心理感受 后悔 烦躁 不断的闪现各种场景 幻想未来又不断的否定 自责]]></content>
      <tags>
        <tag>痛苦</tag>
        <tag>内心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023-2024上半年]]></title>
    <url>%2F2024%2F05%2F14%2F2023-2024.5%2F</url>
    <content type="text"><![CDATA[20232023 我以为是我开始慢慢变好的一年。在这一年里经历了很多 考取了软件设计师证书 养了一只小猫 拿到了年度优秀员工 终于到了要结婚的那一步 。。。。 还有很多很多事情，我觉得我的生活正在越来越好。我的内心深处开始害怕，我一直感觉生活就是像西西弗斯推着石头往上走，我推的越来越高了，我害怕石头落下来。 2024 上石头突然滚下来了，碾碎了，有很多话想说，却什么都说不出来，]]></content>
      <tags>
        <tag>一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac导入pfx证书失败]]></title>
    <url>%2F2024%2F04%2F18%2Fmac_import_pfx_error%2F</url>
    <content type="text"><![CDATA[mac导入pfx证书失败在导入pfx证书的时候输入密码后一直显示密码错误。尝试通过openssl命令先把密码去除了1openssl pkcs12 -in xxx.pfx -clcerts -nokeys -out certificate.crt 结果还是不行：后来发现是openssl版本的原因,14系统的openssl默认是3.x版本，导出的crt不兼容。 通过下面的命令切换openssl版本：1export PATH="/opt/homebrew/opt/openssl@1.1/bin:$PATH" 再次执行下面这条命令后crt文件可以正常导入1openssl pkcs12 -in xxx.pfx -clcerts -nokeys -out certificate.crt]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计git提交]]></title>
    <url>%2F2023%2F11%2F20%2Fgit_count%2F</url>
    <content type="text"><![CDATA[统计git提交因为工作需要，需要统计一个时间段指定用户的git提交的次数，代码改变的行数，以及依据commit特殊前缀来统计次数。脚本如下：&nbsp; 1234567891011121314151617181920212223242526272829303132#!/bin/bash# 获取输入参数email=$1 #example syfangjie@live.cnstart_date=$2#example 2023-01-01end_date=$3#example 2023-10-31REPO_PATH=$4#example "/Users/mikusugar/code/test"# 进入仓库目录cd $REPO_PATH || exit# 统计提交次数commit_count=$(git log --author="$email" --since="$start_date" --until="$end_date" --pretty=oneline | wc -l)# 统计改变行数line_count=$(git log --author="$email" --since="$start_date" --until="$end_date" --pretty=tformat: --numstat | awk '&#123; add += $1 - $2 &#125; END &#123; print add &#125;')# 统计feat提交次数 前缀为feat的feat_count=$(git log --author="$email" --since="$start_date" --until="$end_date" --pretty=oneline | grep -c "feat")# 统计fix提交次数 前缀为fix的fix_count=$(git log --author="$email" --since="$start_date" --until="$end_date" --pretty=oneline | grep -c "fix")echo "用户 $email 在当前git仓库的:"echo "提交次数为 $commit_count 次"echo "对代码的改变行数为 $line_count 行"echo "feat 数量 $feat_count 次"echo "fix 数量 $fix_count 次"]]></content>
      <tags>
        <tag>git</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Random 的多线程效率问题]]></title>
    <url>%2F2023%2F08%2F21%2FThreadLocalRandom%2F</url>
    <content type="text"><![CDATA[Java Random 的多线程效率问题缘起最近在写一个算法的多线程计算时发现效率比单线程还慢，单线程大概计算300S，8个线程却计算了900S，这很不正常。一开始以为是锁的原因，于是把算法里面所有的锁都去掉了（该算法估算几乎不影响最后结果准确性）,锁去掉之后还是很慢，时间几乎没有变化。最后打开jconsole查看线程，发现计算的线程显示 阻止1 等待6之类的。观察调用栈发现了卡在random的调用上。 多线程randomJava的random是多线程是安全的，但是Java的random多线程效率存在问题，为此jdk在1.7之后推出了ThreadLocalRandom，它通过一个线程对应一个专属的random实例解决了多线程下random效率的问题。 它的用法如下： 1ThreadLocalRandom.current()....]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alias抽样算法]]></title>
    <url>%2F2023%2F07%2F31%2FAliasSampling%2F</url>
    <content type="text"><![CDATA[Alias 算法抽样简述对于一个只有两种情况的情景抽样，很简单，例如A的概率是0.4，B的概率是0.6，那么只需要随机数小于0.4就是A，否则是B。 如果扩展多个情况，例如A，B，C的概率分别是0.2，0.3，0.5，一般情况O(1)的方法是生成一个数组[A,A,B,B,B,C,C,C,C,C,C],对数组进行随机抽取，这样比较耗费内存。 Alias也可以在O(1)的方法下取样，并且内存需要更小。&nbsp;还是以上面的A,B,C为例子 把A，B，C的概率 X 3 得到[0.6, 0.9, 1.5] 把它们拆分拼成3组，例如，第一组 0.6的A+0.4的B，第二组0.5的B加0.5的C，第三组1.0的C。 随机抽取三组中的一组后，就类似于只有两种情况，再随机抽取就能取到。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import randomdef alias_setup(probs): K = len(probs) q = [0] * K J = [0] * K # Sort the data into the outcomes with probabilities # that are larger and smaller than 1/K. smaller = [] larger = [] for kk, prob in enumerate(probs): q[kk] = K * prob if q[kk] &lt; 1.0: smaller.append(kk) else: larger.append(kk) # Loop though and create little binary mixtures that # appropriately allocate the larger outcomes over the # overall uniform mixture. while len(smaller) &gt; 0 and len(larger) &gt; 0: small = smaller.pop() large = larger.pop() J[small] = large q[large] = q[large] - (1.0 - q[small]) if q[large] &lt; 1.0: smaller.append(large) else: larger.append(large) return J, qdef alias_draw(J, q): K = len(J) # Draw from the overall uniform mixture. kk = int(random.random() * K) # Draw from the binary mixture, either keeping the # small one, or choosing the associated larger one. if random.random() &lt; q[kk]: return kk else: return J[kk]K = 5N = 1000# Get a random probability vector.probs = [random.random() for i in range(K)]# Normalize the probability vectorprobs = [i / sum(probs) for i in probs]# Construct the table.J, q = alias_setup(probs)# Generate variates.X = [0] * Nfor nn in range(N): X[nn] = alias_draw(J, q)print(probs)print(X) 参考https://lips.cs.princeton.edu/the-alias-method-efficient-sampling-with-many-discrete-outcomes/]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写networkx插件]]></title>
    <url>%2F2023%2F07%2F14%2Fnx_plugin%2F</url>
    <content type="text"><![CDATA[编写networkx插件前言networkx的时候发现在3.0版本支持实验性的插件支持 https://github.com/networkx/networkx/pull/6000 ,支持替换networkx的计算后端，目前比较成熟的后端插件是graphblas https://github.com/python-graphblas/graphblas-algorithms/ ，通过这个插件，可以同时结合networkxAPI的易用性以及graphblas的高性能。networkx插件的原理是利用了python的装饰器。&nbsp;装饰器参考 https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584 networkx里面装饰器的核心代码在 networkx/classes/backends.py:130可以看到下面代码中，它会检查graph对象有没有 __networkx_plugin__ 如果有并且这个插件名已经注册在networkx，那么networkx中就会加载插件后端来进行计算。 关于如何编写插件替换networkx的文档资料，网络上还是比较少，在这里记录一下编写插件的方法。 编写插件名字为你需要编写的插件起一个名字，networkx会用名字去调用插件，本文用nxdemo这个名字说明。 图对象定义一个你的插件用来计算的图对象，在这个类里面，需要定义插件名字 12class Graph: __networkx_plugin__ = "nxdemo" 调度员定义一个调度类。 调度类里面定义nx的函数名指向自定义的算法实现，例如弱联通分量的指向: 12class Dispatcher: weakly_connected_components = nx_plugin_demo.algo.weakly_connected_components 调度类里面可以接着写插件的图对象与nx的图对象转换函数 12 @staticmethoddef convert_from_nx(G: nx.Graph, weight=None, name=None): 1234 @staticmethoddef convert_to_nx(graph): 最后在entry_points(setup.py)里面定义插件调度员位置，这里需要用到插件名字 12345678910from setuptools import setupsetup( ''''''entry_points = &#123; 'networkx.plugins': [ 'nxdemo = nx_plugin_demo.Dispatcher:Dispatcher' ]&#125;) 使用插件执行pip安装编写的插件。 networkx依据传入图对象的类型判断使用哪种后端进行计算 12345678910111213141516171819202122232425262728import networkx as nxfrom nx_plugin_demo.Dispatcher import DispatcherG = nx.DiGraph()# 添加节点G.add_node(1)G.add_node(2)G.add_node(3)G.add_node(4)G.add_node(5)# 添加边G.add_edge(1, 2)G.add_edge(2, 1)G.add_edge(2, 3)G.add_edge(3, 4)# 转换图对象G2 = Dispatcher.convert_from_nx(G)# 调用自定义的弱联通分量计算res = nx.weakly_connected_components(G2)print(res)# networkx原本的弱联通分量计算res2 = list(nx.weakly_connected_components(G))print(res2)]]></content>
      <tags>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python递归爆栈]]></title>
    <url>%2F2023%2F07%2F03%2Fpy_recursion%2F</url>
    <content type="text"><![CDATA[python递归爆栈python 递归函数默认递归深度比较小（在本机测试为1000），可以通过 sys.getrecursionlimit() 函数打印出来。超过 sys.getrecursionlimit()的值就会报错。 123456import sys# 打印本机的值print(sys.getrecursionlimit())# 设置该值sys.setrecursionlimit(100000) 参考https://pegasuswang.github.io/python_data_structures_and_algorithms/19_python%E5%86%85%E7%BD%AE%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/builtins/#_1]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图（稀疏矩阵）的压缩存储 CSR]]></title>
    <url>%2F2023%2F06%2F30%2Fcsr%2F</url>
    <content type="text"><![CDATA[图（稀疏矩阵）的压缩存储 CSR矩阵的压缩CSR 是对稀疏矩阵进行压缩处理，把矩阵压缩成三个数组,值数组（values）、行索引数组（col_index）和列偏移数组（row_offsets）。 值数组：按照矩阵的行顺序依次存储非零元素的值 行索引数组：行索引数组存储了每个非零元素所在的行号 (col_index[i]等于values[i]元素的列数) 列偏移数组：存储了每一行的非零元素在值数组中的起始位置 （第i个元素记录了前i-1行包含的非零元素的数量） &nbsp; 下面举个例子 对于矩阵： 1234[[4, 0, 0, 2], [0, 1, 0, 0], [0, 0, 5, 7], [6, 3, 0, 8]] values: [4, 2, 1, 5, 7, 6, 3, 8] col_index: [0, 3, 1, 2, 3, 0, 1, 3] row_offsets: [0, 2, 3, 5, 8] 矩阵的解压通过row_offsets找到对应的范围，通过col_index确定列，通过values取出值。 以一个例子说明，还是上面的矩阵，假设取[1][1]的值 通过row_offset找到范围 为 [row_offsets[1],row_offset[1+1])即是[2,3) 遍历的col_index的[2,3)，找到col_index[i]==1,即i==2 直接返回values[i]即values[2],也就是1 如果第二步的时候找不到，那么就直接返回0。 对于代码来说就是 12345678def get(self, row: int, col: int) -&gt; int: start = self.row_offsets[row] end = self.row_offsets[row + 1] for i in range(start, end): if self.col_index[i] == col: return self.values[i] return 0 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from typing import Listclass CSR: def __init__(self, matrix: List[List[int]]): # 矩阵的行顺序依次存储非零元素的值 self.values = [] # 行索引数组存储了每个非零元素所在的行号 self.col_index = [] # 列偏移数组存储了每一行的非零元素在值数组中的起始位置 self.row_offsets = [0] self._column_len = len(matrix[0]) for i in range(0, len(matrix)): row_offset = self.row_offsets[-1] for j in range(0, len(matrix[i])): if matrix[i][j] != 0: row_offset += 1 self.values.append(matrix[i][j]) self.col_index.append(j) self.row_offsets.append(row_offset) def get(self, row: int, col: int) -&gt; int: start = self.row_offsets[row] end = self.row_offsets[row + 1] for i in range(start, end): if self.col_index[i] == col: return self.values[i] return 0 def column_len(self) -&gt; int: return self._column_len def row_len(self) -&gt; int: return len(self.row_offsets) - 1m = [[4, 0, 0, 2], [0, 1, 0, 0], [0, 0, 5, 7], [6, 3, 0, 8]]csr = CSR(m)print('values:')print(csr.values)print('col_index:')print(csr.col_index)print('row_offsets:')print(csr.row_offsets)print("decompression：")d_m = []for i in range(0, csr.row_len()): a = [] for j in range(0, csr.column_len()): a.append(csr.get(i, j)) d_m.append(a)print(d_m)]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在minikube 上运行 graphscope]]></title>
    <url>%2F2023%2F05%2F29%2Frunning_graphscope_on_minicube%2F</url>
    <content type="text"><![CDATA[在minikube 上运行 graphscope1.环境安装 安装docker环境。 安装minikube。https://minikube.sigs.k8s.io/docs/start/ python版本升级到 3.7 - 3.9。 安装GraphScope 客户端 12345# Requires the latest pippip3 install --upgrade pip# Current stable releasepip3 install --upgrade graphscope-client &nbsp; 2. 启动2.1 minikube 启动 minikube 1minikube start minikube映射 1minikube mount $HOME:/host 例如这里把 本机的home目录映射到minikube的 /host目录下。 参考 https://minikube.sigs.k8s.io/docs/handbook/mount/ mount 需要一直挂在终端，建议tmux启动 mount映射功能需要较新的Linux内核，我之前用3.x的内核失败了，后来升级成了5.x的内核就可以了。 minikube修改时区方法,在宿主机执行 123456789101112&gt; mkdir -p ~/.minikube/files/etc&gt; cp /etc/localtime ~/.minikube/files/etc### 2.2 启动graphscope```pythonimport graphscopeif __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session() print(sess) 第一次启动的时候会去拉取镜像，可能需要比较久 例如会看到这样的日志打印 12023-05-29 02:27:33,087 [INFO][kubernetes_launcher:553]: [gs-engine-cltlyf-0]: Pulling image "registry.cn-hongkong.aliyuncs.com/graphscope/interactive-executor:0.21.0" 也可以提前在本机准备好镜像，然后导入到minikube中 以上面的镜像为例子 123456789# 准备镜像## 下载镜像docker pull registry.cn-hongkong.aliyuncs.com/graphscope/interactive-executor:0.21.0## 找到镜像IDdocker images | grep registry.cn-hongkong.aliyuncs.com/graphscope/interactive-executor## 生成镜像文件docker save -o interactive-executor.tar d8cdf0b6f8db # 导入到minikubeminikube image load interactive-executor.tar 启动成功后 可以通过 kubectl get pods看到，graphscope启动了4个pods 123456[miku@centos7 gsremote]$ kubectl get podsNAME READY STATUS RESTARTS AGEcoordinator-ysagwr-65c5d7f6f9-ppcb7 1/1 Running 0 23sgs-engine-ysagwr-0 4/4 Running 0 20sgs-engine-ysagwr-1 4/4 Running 0 13sgs-interactive-frontend-ysagwr-7c696bdc7d-4vct5 1/1 Running 0 19s 参考https://graphscope.io/docs/v0.20.0/reference/session#session获取sess 如果遇到执行结束后，pods却还一直在运行，可以通过下面的命令删除 1234567891011121314&gt; # 找到当前的deployments&gt; kubectl get deployments&gt; # 删除 graphscope 相关的 deployments&gt; kubectl delete deployments deployments_name&gt; # 如果全部都是graphscope相关的 deployments，也可以直接删除所有&gt; kubectl delete deployments --all&gt; &gt; # 找到当前的statefulsets&gt; kubectl get statefulsets&gt; # 删除grahpscope相关的statefulsets&gt; kubectl delete statefulset statefulset_name&gt; # 如果全部都是rahpscope相关的statefulsets，也可以直接删除所有&gt; kubectl delete statefulset --all&gt; 3. 图的导入以p2p-network 为例子 参考: https://graphscope.io/docs/v0.20.0/zh/loading_graph#id3 https://nbviewer.org/github/alibaba/GraphScope/blob/main/tutorials/zh/04_loading_graphs.ipynb 3.1 直接通过网络导入映射准备需要把本地的home目录最终映射到k8s的home目录，例如本地的用户是miku，home目录是 /home/miku。 需要把 /home/miku目录映射到k8s的/home/miku目录上。 可以这样做： 执行mount命令，映射本地/home/miku到minikube上的/home/miku 1minikube mount /home/miku:/home/miku 在python代码中配置k8s上映射 我们需要把minikube上的/home/miku映射到k8s上的/home/miku 123456789101112k8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125; 图的导入（完整代码）12345678910111213141516171819202122import graphscopefrom graphscope.dataset import load_p2p_networkk8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) print(sess) g = load_p2p_network(sess, directed=True) print(g.schema) 最后可以看到图的结构打印 12345678910oid_type: LONGvid_type: ULONGtype: VERTEXLabel: hostProperties: Property(0, weight, LONG), Property(1, id, LONG)type: EDGELabel: connectProperties: Property(0, eid, LONG), Property(1, src_label_id, LONG), Property(2, dst_label_id, LONG), Property(3, dist, LONG)Relations: [Relation(source='host', destination='host')] 3.2 本地离线导入数据准备我们可以提前准备好点和边的文件。 下载 graphscope p2p-networkd的数据 https://github.com/MikuSugar/data/blob/master/p2p_network.tar.gz 解压后放在一个目录上，例如我放在 /home/miku/test_data/p2p_network 目录内如下 1234[miku@centos7 p2p_network]$ lltotal 3144-rwxrwxrwx. 1 miku miku 2723852 Nov 16 2021 p2p-31_property_e_0-rwxrwxrwx. 1 miku miku 489592 Nov 16 2021 p2p-31_property_v_0 映射准备目的是要让数据文件目录映射到k8s上，让graphscope能够读取到数据。 可以这样做 把本地目录映射到minikube上 1minikube mount /home/miku:/host 在python代码中配置k8s上的映射 123456789101112k8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/host/test_data/", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/testingdata" &#125; &#125;&#125; 完整代码12345678910111213141516171819202122232425262728293031323334import graphscopefrom graphscope.dataset import load_p2p_networkk8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/host/test_data/", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/testingdata" &#125; &#125;&#125;if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) print(sess) g = load_p2p_network(sess, "/testingdata/p2p_network/") print(g.schema) # 手动指定文件导入 g1: Graph = sess.g(directed=False) g1 = g1.add_vertices( "/testingdata/p2p_network/p2p-31_property_v_0", label="host" ).add_edges( "/testingdata/p2p_network/p2p-31_property_e_0", label="connect", src_label="host", dst_label="host", ) print(g1.schema) 这里导入的图的结构与3.1一致。 4. 运行算法为了方便，下面都采用3.1的方法导入图,用sssp算法举例。 参考 https://graphscope.io/docs/v0.20.0/zh/analytics_engine 文档有一些问题，已经反馈给grapescope,下个版本修复（当前版本0.21.0） https://github.com/alibaba/GraphScope/discussions/2735 4.1 运行内置算法12345678910111213141516171819202122232425262728import graphscopefrom graphscope.dataset import load_p2p_networkfrom pandas import DataFramek8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) print(sess) g = load_p2p_network(sess, directed=True) print(g.schema) g2 = g.project(vertices=&#123;"host": ["id"]&#125;, edges=&#123;"connect": ["dist"]&#125;) res = graphscope.sssp(g2, src=6) print(res.schema) r_df: DataFrame = res.to_dataframe(&#123;"node": "v.id", "result": "r"&#125;).sort_values(by=["node"]) print(r_df.head(20)) 4.2 运行自定义pregel算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import graphscopefrom graphscope.analytical.udf.decorators import pregelfrom graphscope.dataset import load_p2p_networkfrom graphscope.framework.app import AppAssetsfrom graphscope.framework.context import VertexDataContextDAGNodek8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;@pregel(vd_type="int", md_type="double")class SSSP_Pregel(AppAssets): @staticmethod def Init(v, context): v.set_value(1000000000) @staticmethod def Compute(messages, v, context): src_id = context.get_config(b"src") cur_dist = v.value() new_dist = 1000000000 if v.id() == src_id: new_dist = 0 for message in messages: new_dist = min(message, new_dist) if new_dist &lt; cur_dist: v.set_value(new_dist) for e_label_id in range(context.edge_label_num()): edges = v.outgoing_edges(e_label_id) for e in edges: v.send(e.vertex(), new_dist + e.get_int(3)) v.vote_to_halt() @staticmethod def Combine(messages): ret = 1000000000.0 for m in messages: ret = min(ret, m) return retif __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) g = load_p2p_network(sess) print(g.schema) my_app = SSSP_Pregel() ret: graphscope.framework.context.Context = my_app(g, src=6) r = ret.to_dataframe(&#123;"node": "v:host.id", "result": "r:host"&#125;).sort_values(by=["node"]) print(r.head(20)) 4.3 运行自定义PIE算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import graphscopefrom graphscope.dataset import load_p2p_networkfrom graphscope.analytical.udf.decorators import piefrom graphscope.framework.app import AppAssetsk8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;@pie(vd_type="double", md_type="double")class SSSP_PIE(AppAssets): @staticmethod def Init(frag, context): v_label_num = frag.vertex_label_num() for v_label_id in range(v_label_num): nodes = frag.nodes(v_label_id) context.init_value( nodes, v_label_id, 1000000000.0, PIEAggregateType.kMinAggregate ) context.register_sync_buffer(v_label_id, MessageStrategy.kSyncOnOuterVertex) @staticmethod def PEval(frag, context): src = context.get_config(b"src") graphscope.declare(graphscope.Vertex, source) native_source = False v_label_num = frag.vertex_label_num() for v_label_id in range(v_label_num): if frag.get_inner_node(v_label_id, src, source): native_source = True break if native_source: context.set_node_value(source, 0) else: return e_label_num = frag.edge_label_num() for e_label_id in range(e_label_num): edges = frag.get_outgoing_edges(source, e_label_id) for e in edges: dst = e.neighbor() distv = e.get_int(3) if context.get_node_value(dst) &gt; distv: context.set_node_value(dst, distv) @staticmethod def IncEval(frag, context): print(context.superstep(), flush=True) v_label_num = frag.vertex_label_num() e_label_num = frag.edge_label_num() for v_label_id in range(v_label_num): iv = frag.inner_nodes(v_label_id) for v in iv: v_dist = context.get_node_value(v) for e_label_id in range(e_label_num): es = frag.get_outgoing_edges(v, e_label_id) for e in es: u = e.neighbor() u_dist = v_dist + e.get_int(3) if context.get_node_value(u) &gt; u_dist: context.set_node_value(u, u_dist)if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) g = load_p2p_network(sess) print(g.schema) my_app = SSSP_PIE() ret = my_app(g, src=6) r = ret.to_dataframe(&#123;"node": "v:host.id", "result": "r:host"&#125;).sort_values(by=["node"]) print(r.head(20)) 4.4 运行flash算法 这里以K-core算法为例子，参考 https://github.com/alibaba/GraphScope/tree/main/python/graphscope/analytical/app/flash 完整代码 123456789101112131415161718192021222324252627import graphscopefrom graphscope.dataset import load_p2p_networkk8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) g = load_p2p_network(sess) print(g.schema) pg = g.project(vertices=&#123;"host": []&#125;, edges=&#123;"connect": []&#125;) print(pg.schema) c = graphscope.flash.kcore_searching(pg, k=5) print(c.schema) print(c.to_numpy("r")[0]) flash算法编写参考 https://github.com/alibaba/GraphScope/tree/main/analytical_engine/apps/flash 5. 交互式运行参考 https://graphscope.io/docs/v0.20.0/zh/interactive_engine https://nbviewer.org/github/alibaba/GraphScope/blob/main/tutorials/zh/01_node_classification_on_citation_network.ipynb 完整代码 1234567891011121314151617181920212223242526272829import graphscopefrom graphscope.dataset import load_ogbn_magk8s_volumes = &#123; "data": &#123; "type": "hostPath", "field": &#123; "path": "/home/miku", "type": "Directory" &#125;, "mounts": &#123; "mountPath": "/home/miku" &#125; &#125;&#125;if __name__ == '__main__': graphscope.set_option(show_log=True) sess = graphscope.session(k8s_volumes=k8s_volumes) graph = load_ogbn_mag(sess) print(graph.schema) # Get the entrypoint for submitting Gremlin queries on graph g. interactive = graphscope.gremlin(graph) # Count the number of papers two authors (with id 2 and 4307) have co-authored. papers = interactive.execute( "g.V().has('author', 'id', 2).out('writes').where(__.in('writes').has('id', 4307)).count()" ).one() print("result", papers)]]></content>
      <tags>
        <tag>图计算</tag>
        <tag>graphscope</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简化输入数据很重要]]></title>
    <url>%2F2023%2F03%2F08%2F%E7%AE%80%E5%8C%96%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BE%88%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[最近实现一个算法，最初懒，直接拿原始图依照需求直接算，没想到后面出现需求变动，需要算更深的度，计算量爆炸，再加上比最初约定的数据大很多，边直接多了五倍多！&nbsp;直接就跑不动了，后面开始优化。首先内存不够硬盘来凑，用paldb来替换原来存储再内存的消息，paldb的读取性能挺让我惊喜的，与内存的map差距不大。这样改下来还是算不动。。。把输入的图进行简化，简化后点的数量减少了1/3，边的数量减少了75%。对简化的图进行计算。算法迭代次数从原来的9次减少到3次，算法核心计算代码减少了50%，内存由原来的200G跑不动到128GB可以跑。。。以后不能偷懒，要先想想输入的数据能不能简化一下。。。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fifsky/ssh-action使用nohup命令后无法结束]]></title>
    <url>%2F2023%2F01%2F27%2Fssh-action%2F</url>
    <content type="text"><![CDATA[缘起fifsky/ssh-action@master是GitHub Action的一个插件，用于在GitHub Action中远程登录主机执行命令。 最近写了一个脚本，结果发现github action一直处于运行状态，实际已经执行完了，最后发现是执行nohup后，ssh-action无法判定命令是否结束。 解决https://github.com/appleboy/ssh-action/issues/40 通过重定向所有输出解决 1nohup python script.py &gt; nohup.out 2&gt; nohup.err &lt; /dev/null &amp; For some reason, the action keeps waiting for stdin, stdout, and stderr. That’s why we need to redirect all three outputs to free the terminal. That’s all I could gather from this…]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏机]]></title>
    <url>%2F2023%2F01%2F22%2F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[大年初一，来了亲戚做客，我带着两个小朋友玩NS。 马车教一个小朋友说 按A前进，她妈妈说，她才三岁，懂个屁的A。。。 一个小朋友回家前问我说，你在读高中还是大学啊？ 大概没有我这样带他们打游戏的大人存在。。。]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次算法迭代无法结束bug]]></title>
    <url>%2F2023%2F01%2F16%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E6%97%A0%E6%B3%95%E7%BB%93%E6%9D%9Fbug%2F</url>
    <content type="text"><![CDATA[用自己写的pregel算法框架实现了一个算法，在单机情况下正常执行，在分布式下计算结束需要的迭代次数大幅增加，甚至无法结束。 从逻辑上来讲，单机与分布式计算的迭代次数应该是一致的，不应该出现这种情况。 &nbsp; pregel算法框架封装了多线程以及分布式的细节，怀疑是框架本身的问题(自己写的框架不够自信了….),排查了一天多还是没找到问题，后来又发现了分布式计算的结果每次条数都不一样，倒推出了数据加载出了问题，最后发现是算法加载数据的时候一个方法传错了参数,导致了一个属性获取错误，这个方法的参数在单机时传错了也没有影响。。。 这次bug排查花了比较长时间，大概有两个原因。 算法的逻辑是在动态加载的jar包里，目前还没找到打断点比较好的方法。只能靠打日志。 违背了先从小地方找原因的原则。排查错了地方，一开始在排查框架侧。。。]]></content>
      <tags>
        <tag>算法</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022]]></title>
    <url>%2F2022%2F12%2F31%2F2022%2F</url>
    <content type="text"><![CDATA[20222022年正好是我的本命年，今年发生了许多。 今年我大概有30-40%的工作时间处于居家办公，因为疫情、高温限电。（再次确认了我真的是一个死宅。 上半年在上海的时候还体验到了以物换物，离开上海前夕回公司拿东西的时候还遇上了临时封控，折腾到晚上10点才放走。 经历了铁皮房集中隔离。&nbsp; 换城市，从上海来到了成都，工作方向也换了，由Hadoop大数据变成了分布式图算法，记得大学毕业之前就想以后工作从事算法多好，现在实现了，虽然是小厂，但我挺满意的，朝九晚五，不卷，工作方向还是自己感兴趣的。来到了成都后感觉没在上海那么焦虑了，这边唯一的缺点就是感觉阳光太少了，其它都挺好的，吃的很合我口味，生活成本比上海低多了，居住环境大幅提高。。。（在上海大家都互相称呼同学，在成都都互相称呼为老师，不知道为啥子）。 后半年开始锻炼身体，每天40分钟到1小时我居然连续坚持了一百多天，现在暂时停了，担心心肌炎，等过几天再开始。 在2022年的最后一天，也就是今天，还整了一台ps4，太想玩神海123了。。。 。。。。 TODO 开发一个APP上架APP Store（希望能体会到躺着赚钱的感觉(&gt;^ω^&lt;) 锻炼身体（我一定要锻炼出八块腹肌(╯‵□′)╯ 学习英语 照片2月在会议室随手拍的 和源源一起种的 以为没动静的水仙花开花了 封控期间好不容易才抢到的蔬菜包 小叮当和天竺鼠车车 离开上海拍的屋子窗外 在成都屋子里烤肉串 成都街头 小熊猫 大熊猫基地天鹅湖 大熊猫 锻炼100天 下班路上的落日]]></content>
      <tags>
        <tag>一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache giraph 调研文档]]></title>
    <url>%2F2022%2F12%2F23%2FApacheGiraph%E8%B0%83%E7%A0%94%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[apache giraph 调研文档[TOC] 1. 背景介绍Apache Giraph是一个为高可扩展性而构建的迭代图形处理系统。Giraph起源于Pregel的开源对应架构，Pregel是谷歌开发的图形处理架构，并在2010年的一篇论文中进行了描述。这两个系统的灵感都来自Leslie Valiant引入的分布式计算的批量同步并行模型。Giraph在基本Pregel模型之外添加了几个功能，包括主计算、分片聚合器、面向边缘的输入、核心外计算等。&nbsp; 2. giraph 项目结构下面是项目目录中的主要目录介绍。 12345678910111213141516171819202122232425262728293031323334353637- giraph #项目根目录 - giraph-block-app #giraph block api 的实现，不在本次调研范围内 - giraph-core #giraph pregel计算的核心实现，本次调研主要关注范围 -src/main/java - com.yammer.metrics.core #一些空的指标实现 - org.apache.giraph ├── Algorithm.java #内置算法的名字注释 ├── GiraphRunner.java #提交在hadoop上运行的任务入口 ├── aggregators #giraph的聚合器相关 ├── benchmark #基准测试 ├── bsp #bsp的对象包 ├── combiner #消息的Combiner包 ├── comm #通信相关的包 ├── conf #配置相关的包 ├── counters #处理hadoop记数的包 ├── edge #图的边的包 ├── factories #工厂包，用于创建各种类型 ├── function #函数接口包， ├── graph #与图形相关的包，关键的计算接口Computation也在这里 ├── io #io相关的包 ├── job #job启动中涉及的包 ├── jython #jython集成包 ├── mapping #主要是mappingstore ├── master #与master有关的对象包 ├── metrics #指标相关的包 ├── ooc #核心外围的包 ├── partition #分区相关的对象包 ├── reducers #reduce 相关的包 ├── scripting #giraph 脚本相关的包 ├── time #time相关的包 ├── types #类型转换相关的包 ├── utils #工具类 ├── worker #计算节点work相关的包 ├── writable #kryo和tuple相关的包 ├── yarn #hadoop yarn相关的包 └── zk #zookeeper相关的包 - giraph-examples 一些例子代码，和可供调试的单元测试 3. giraph 编译调试3.1 拉取代码1git clone git@github.com:apache/giraph.git 3.2 编译打包1mvn -DskipTests=true package -P hadoop_2,hadoop_trunk 3.3 调试本次调研只描述单机通过giraph-examples中的单元测试进行调试。 idea maven 的配置文件勾选hadoop_2,hadoop_trunk 以org.apache.giraph.examples.MaxComputationTest为例： 如需调试任务提交流程，可直接在单元测试方法内打断点。 如需调试计算流程，可在org.apache.giraph.graph.GraphMapper中的run方法打断点。 如需调试任务启动流程，可在org.apache.giraph.graph.GraphMapper中的setup方法打断点。 4. giraph 计算流程4.1 zookeeper 简单介绍 giraph 利用来zookeeper来进行选主以及计算的同步，有必要对zookeeper进行简单介绍来更易于理解giraph的计算流程。 （下文zk等同于zookeeper） zk的数据结构是一个具有层次的数据结构，类似于文件系统。 graph LR A["/"] A-->B["/NameService"] B-->B1["/server1"] B-->B2["/server2"] B-->B3["/server3"] A-->C["/conf"] A-->D["/Apps"] D-->D1["/app1"] D-->D2["/app2"] D-->D3["/app3"] D3-->E["/subApp1"] D3-->E1["/subApp2"] 这种数据结构有如下特点： 每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/server1 znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录， znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据 znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了 znode 的目录名可以自动编号，如 app1 已经存在，再创建的话，将会自动命名为 app2 znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性，Zookeeper 的很多功能都是基于这个特性实现的 zk的应用举例： 统一命名服务（NameService）： 分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住。 Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。 配置管理： 可以将配置信息保存在zk的某个节点中，当配置信息发生变化时，每台应用节点都会收到zk的通知，便可从zk获取最新的配置信息到本节点。 Master选举： 分布式系统一个重要的模式就是主从模式 (Master/Salves)，Zookeeper 可以用于该模式下的 Matser 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 Zookeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Master 节点。 分布式锁： 分布式系统的所有服务节点可以竞争性地去创建同一个临时 ZNode，由于 zl不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，此时可以认为该节点获得了锁。其他没有获得锁的服务节点通过在该 ZNode 上注册监听，从而当锁释放时再去竞争获得锁。锁的释放情况有以下两种： 当正常执行完业务逻辑后，客户端主动将临时 ZNode 删除，此时锁被释放； 当获得锁的客户端发生宕机时，临时 ZNode 会被自动删除，此时认为锁已经释放。 当锁被释放后，其他服务节点则再次去竞争性地进行创建，但每次都只有一个服务节点能够获取到锁，这就是排他锁 集群管理： 如可以通过创建临时节点来建立心跳检测机制。如果分布式系统的某个服务节点宕机了，则其持有的会话会超时，此时该临时节点会被删除，相应的监听事件就会被触发。 分布式系统的每个服务节点还可以将自己的节点状态写入临时节点，从而完成状态报告或节点工作进度汇报。 通过数据的订阅和发布功能，zk 还能对分布式系统进行模块的解耦和任务的调度。 通过监听机制，还能对分布式系统的服务节点进行动态上下线，从而实现服务的动态扩容。 4.2 Giraph中的MapReducegiraph 利用来MapReduce的Mapper接口（org.apache.giraph.graph.GraphMapper），但是并没有用Mapper接口最重要的map方法，而是重写了setup、cleanup和run方法，giraph只是通过mr来利用Hadoop yarn集群中的计算节点，下面简单介绍一下Mapper接口的setup、cleanup和run方法。 setup: 此方法被MapReduce框架仅且执行一次，在执行Map任务前，进行相关变量或者资源的集中初始化工作。 giraph利用setup来初始化GraphTaskManager。 run:此方法是MapReduce中mapper task调用的方法，可以看到在这个方法默认实现中一开始调用了setup方法，循环中调用了map方法，最后调用了cleanup方法。 giraph中改写了这个方法，没有调用map方法，调用了setup中初始化的GraphTaskManager的execute() 方法，并且在计算异常时主动删除zk节点，以更快的通知其它节点。 cleanup：此方法在Map任务的最后阶段调用，执行清理操作。 MapReduce任务需要通过代码手动组装任务并提交到yarn集群中，在giraph中通过org.apache.giraph.GiraphRunner提交任务到yarn集群，具体的执行逻辑在org.apache.giraph.job.GiraphJob#run方法里，这里有一个点简单说一下： 在GraphMapper的run方法中我们可以看到 1234567&gt; //....&gt; while (context.nextKeyValue()) &#123;&gt; graphTaskManager.execute();&gt; &#125;&gt; //....&gt; &gt; 是在一个while循环里调用execute方法，其实这个循环只会执行一次，这说明context里面只读取到了一个值，这个读取的值通过org.apache.giraph.job.GiraphJob#run方法里的 12&gt; submittedJob.setInputFormatClass(BspInputFormat.class);&gt; BspInputFormat.class决定，通过这个类里的createRecordReader决定，这里只返回了一个BspRecordReader，可以看到这个对象里面只会返回一对值，所以这个循环只会出现一次。 另外介绍一下Map中Contex contex的context.progress()方法，这个方法是用来报告自己的状态 4.3 BSP4.3.1 mastermaster 的运行逻辑在org.apache.giraph.master.MasterThread的run()方法里。 graph LR A["检查工人状态"]-->B["拆分数据"] B-->C["执行超步循环"] 超步循环最核心的逻辑在 org.apache.giraph.master.BspServiceMaster#coordinateSuperstep方法里 graph TB A["assignPartitionOwners() 1,生成partitionOwners集合 2,zk中创建vertexExchangePath节点 3,向每个work发送分区信息"] A-->B["通过调用barrierOnWorkerList方法来检查work是否写完检查点"] B-->C["发送聚合器，如果是第一次则初始化聚合器"] C-->D["通过调用barrierOnWorkerList方法来检查work是否完成工作"] D-->E["收集所有聚合值计算并存储"] E-->F["判断计算是否需要停止"] F-->G["创建完成zk节点,把聚合统计信息写入节点"] barrierOnWorkerList 原理：创建一个zk中的znode节点，查找该节点的子节点数量是否等于work数量，不想等则进入线程等待状态，后面只要有work在改znode下创建子节点便会触发继续判断是否相等。 4.3.2 clientclient的运行逻辑在 org.apache.giraph.graph.GraphTaskManager#execute方法里 execute方法里的while循环便是work超步的循环。 serviceWorker.startSuperstep() 超步计算开始前的准备工作 graph LR; A["prepareSuperstep()处理上一步的消息"] B["registerHealth通过向zk注册节点表明自己的健康状况"] A-->B B-->C["等待分区数据的分配完成"] C-->D["从上一个超步拿到聚合值通过getSuperstep()从zk获取"] serviceWorker.exchangeVertexPartitions(masterAssignedPartitionOwners) graph LR A["updatePartitionOwners获取最新的分区信息"] A-->B["sendWorkerPartitions将分区发送给所有work"] B-->C["getApplicationAttempt在zk创建一个节点，代表当前节点完成"] C-->D["等待依赖节点完成通过检查zk vertexExchangePath下的节点"] processGraphPartitions 执行每一个超步具体的计算 生成 ComputeCallable来做具体的计算工作，通过里面的call来执行具体的计算逻辑 graph TB A["初始化计算线程"] A-->B["获取写入顶点的接口"] B-->C["创建计算的对象Computation的实例"] C-->D["初始化计算对象和执行计算对象前置方法"] D-->E["获取分区存储、OutOfCoreEngine、taskManager"] E-->F["获取一个分区partition"] F-->G{"partion是否为空"} G-->|Yes| GOK["退出循环,执行计算后的后置操作"] G-->|No| GNO["处理分区数据变化"] GNO-->H1["获取分区的点集合"] H1-->H2{"是否忽视现有点"} H2-->|Yes|H3["遍历分区内目标点的集合1,获取点的消息2,调用计算对象的compute计算3,去除计算过的消息"] H2-->|No|H4["遍历分区的所有点的集合1,获取点的消息2,依据点的状态和是否有消息判断是否计算3,处理边的变化，保存点，去除计算过的消息"] H3-->H5["清理分区"] H4-->H5 subgraph "computePartition 计算分区数据" H1 H2 H3 H4 H5 end H5-->J["一些指标的统计"] J-->F GOK-->L["flush 消息"] completeSuperstepAndCollectStats 方法里处理每个超步的计算结束。 org.apache.giraph.worker.BspServiceWorker#finishSuperstep graph LR A["waitForRequestsToFinish 等待所有未完成的请求完成"] B["globalCommHandler.finishSuperste 计算聚合器的值发送结果给master"] A-->B B-->C["writeFinshedSuperstepInfoToZK将完成的超步信息写入到zk"] C-->D["waitForOtherWorkers通过等待master创建完成zk完成标志节点"] 4.4 pregel4.4.1 pregel 简述Pregel的计算过程是由一系列被称为“超步”的迭代组成的。 在每个超步中，每个顶点上面都会并行执行用户自定义的函数，该函数描述了一个顶点V在一个超步S中需要执行的操作。 该函数可以读取前一个超步(S-1)中其他顶点发送给顶点V的消息，执行相应计算后，修改顶点V及其出射边的状态，然后沿着顶点V的出射边发送消息给其他顶点，而且，一个消息可能经过多条边的传递后被发送到任意已知ID的目标顶点上去。 graph LR title[顶点之间的消息传递] style title fill:#FFF,stroke:#FFF A["A compute()计算"] B["B compute()计算"] D["C compute()计算"] A---B A---D A.->|"消息"|B B.->|"消息"|A A.->|"消息"|D D.->|"消息"|A 这些消息将会在下一个超步(S+1)中被目标顶点接收，然后像上述过程一样开始下一个超步(S+1)的迭代过程。 在Pregel计算过程中，一个算法什么时候可以结束，是由所有顶点的状态决定的。 在第0个超步，所有顶点处于活跃状态。 当一个顶点不需要继续执行进一步的计算时，就会把自己的状态设置为“停机”，进入非活跃状态。 当一个处于非活跃状态的顶点收到来自其他顶点的消息时，Pregel计算框架必须根据条件判断来决定是否将其显式唤醒进入活跃状态。 当图中所有的顶点都已经标识其自身达到“非活跃（inactive）”状态，并且没有消息在传送的时候，算法就可以停止运行。 graph LR title[状态变化] style title fill:#FFF,stroke:#FFF A(("活跃"))--"不需要执行进一步计算"-->B(("不活跃")) B--"收到消息后"-->A 4.4.2 giraph 代码例子最根本的是org.apache.giraph.graph.Computation接口，最重要的是实现里面的compute方法。 compute方法会在4.3.2 client 中的ComputeCallable的call来调用 compute的方法实现，例如求连通分量中的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Override public void compute( Vertex&lt;IntWritable, IntWritable, NullWritable&gt; vertex, Iterable&lt;IntWritable&gt; messages) throws IOException &#123; int currentComponent = vertex.getValue().get(); // First superstep is special, because we can simply look at the neighbors if (getSuperstep() == 0) &#123; for (Edge&lt;IntWritable, NullWritable&gt; edge : vertex.getEdges()) &#123; int neighbor = edge.getTargetVertexId().get(); if (neighbor &lt; currentComponent) &#123; currentComponent = neighbor; &#125; &#125; // Only need to send value if it is not the own id if (currentComponent != vertex.getValue().get()) &#123; vertex.setValue(new IntWritable(currentComponent)); for (Edge&lt;IntWritable, NullWritable&gt; edge : vertex.getEdges()) &#123; IntWritable neighbor = edge.getTargetVertexId(); if (neighbor.get() &gt; currentComponent) &#123; sendMessage(neighbor, vertex.getValue()); &#125; &#125; &#125; vertex.voteToHalt(); return; &#125; boolean changed = false; // did we get a smaller id ? for (IntWritable message : messages) &#123; int candidateComponent = message.get(); if (candidateComponent &lt; currentComponent) &#123; currentComponent = candidateComponent; changed = true; &#125; &#125; // propagate new component id to the neighbors if (changed) &#123; vertex.setValue(new IntWritable(currentComponent)); sendMessageToAllEdges(vertex, vertex.getValue()); &#125; vertex.voteToHalt(); &#125;]]></content>
      <tags>
        <tag>图计算</tag>
        <tag>giraph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VF3剪枝调研]]></title>
    <url>%2F2022%2F12%2F22%2FVF3%E7%AE%97%E6%B3%95%E5%89%AA%E6%9E%9D%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[VF3剪枝调研0. 前言定义 g1为小图，模式图 g2为大图 伪代码 &nbsp; 1. 点的优先级这里的点的优先级指的是遍历枚举中g1的点的优先级，优先考虑约束多的点， 在大图g2中找到对应节点的可能性比较小的优先。 和已经匹配上的节点连接比较多的应该优先。 通过这样判断枚举的点的优先级可以尽快的剪掉不可能的分支。 1.1 点的匹配概率定义pf(u)为在g2中找到一个节点v可以和g1中节点u匹配上的概率。 其中 λu1(u)指u在g1中的标签,λv2(v)指v在g2中的标签 din是入度 dout是出度 v和u匹配，必须满足3个条件 两个节点的label相同 g2中节点的v的入度不小于g1中节点u的入度 g2中节点的v的出度不小于g1中节点u的出度 pf(u)就是同时满足这3个条件的概率，计算这个概率的时间复杂度最差为On3,于是看成3个独立的条件概率，公式可以变为 其中pl(l)是节点v的label是l的概率，这个计算的复杂度下降为On。 1.2 点的匹配顺序定义g1中点的顺序为ng1,定义dm为一个节点与已经加入ng1里的节点相连的数量。 排序规则： dm大的优先级高 dm相等的情况下按pf排序，pf小的优先级高 dm和pf都相等的情况下，考虑节点的度，度大的节点优先级高 如果三者都相等，则顺序任意 按上述排序规则取出优先级最高的点加入ng1，不断的重复上述过程知道所有的点都已经加入ng1。 2. 状态可行性判断定义Sc 为一个符合匹配的一致状态，判断要新加入的的候选节点对（un,vn）是否可行，需要保证这个节点对加入Sc后，Sc依赖是符合匹配的。 un 是 g1(小图)中的节点，vn是g2(大图)中的节点 S1(un)是un节点的所有后续节点构成的集合，P1(un)是un节点的所有前驱节点构成的集合，S2(vn),P2(vn)同理。 M1(Sc)表示Sc中属于g1图的节点集合，M2(Sc)表示Sc中属于g2图的节点。 表示M(s)中与u对应的点。 表示M(s)中与v对应的点。 通俗的说就是un与已经匹配上的M1(Sc)中的关系和vn与已经匹配上的M2(Sc)中的关系要一模一样的，un有的，vn也要有，不能多也不能少，方向也要一致。 3. 未来状态判断3.1 1-lookahead3.1.1 定义 V1代表g1图中的点集合 E1代码g1图中边的集合 ~P1(s) 表示 g1中去除已经在匹配状态的点 剩下的与匹配状态中的点是前驱节点的集合 ~S1(s) 表示 g1中去除已经在匹配状态的点 剩下的与匹配状态中的点是后续节点的集合 表示～P1(S)中属于种类i的节点的集合。 下标为2的时候代表g2图。 3.1.2 判断公式 对任意种类的点，g1(小图)中的点的数量都不能大于g2(大图)中的点的数量，否则未来就必然会匹配不上。 3.2 2-lookahead更进一步考虑未来的情况 3.2.1 定义 代表在~V1(s)中属于i种类的点的集合 下标为1代表g1，下标为2代表g2 3.2.2 公式 需要满足小图中符合条件的点的集合大小不大于大图中符合条件的点集合大小。 4. 参考https://blog.csdn.net/weixin_33187773/article/details/113055063]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图计算</tag>
        <tag>子图同构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022-新的开始]]></title>
    <url>%2F2022%2F06%2F11%2F2022-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[2022/06/08 早上 离开上海，坐上🚄前往成都，大概在上海被困了三个多月，恍如隔世。 随着高铁的启动，一直高压的心才终于放松下来。 2022/06/10 这一天 正式离职了。感觉到一身轻松。 我的2022正式开始了（虽然已经过半了）。]]></content>
      <tags>
        <tag>一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[龙鸣]]></title>
    <url>%2F2021%2F07%2F19%2F%E9%BE%99%E9%B8%A3%2F</url>
    <content type="text"><![CDATA[做了一个梦，梦中我和一些人正在穿越河流，河比较浅，有很多荷叶，但是没看到荷花。 突然，我听到一声 很大，不知道怎么描述的声音，整个人感觉麻的。旁边有人说了一句话： “龙的鸣叫声可以给人带来勇气。” 我抬头望天，看到一条巨龙在飞，龙飞走后，周围的人继续向前走。]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个梦]]></title>
    <url>%2F2021%2F07%2F19%2F%E4%B8%80%E4%B8%AA%E6%A2%A6%2F</url>
    <content type="text"><![CDATA[今天凌晨做了一个挺有意思的梦。 梦里面 高中学校举办了一个活动，让我们这些毕业了五年的回到高中再上一礼拜的课。 活动的主旨是让大家恢复活力。在梦里上着课的我突然想到，为啥高中从早上六点多去学校，晚上十多点再回来却不累。 （现实上班时间没这么长却累） 在梦里面我感觉我的活力补充回来了。另外不知道为啥在梦里 教语文的是英语老师😄。 其余的细节记不清楚了。醒来的时候有点难受。]]></content>
      <tags>
        <tag>随便写写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021]]></title>
    <url>%2F2021%2F03%2F26%2F2021%2F</url>
    <content type="text"><![CDATA[2020和朋友聊天说要变强。 现在依然觉得自己很菜，继续努力吧。 2021还是希望变强。]]></content>
      <tags>
        <tag>一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两朵阳光下的花]]></title>
    <url>%2F2020%2F09%2F13%2F%E4%B8%A4%E6%9C%B5%E9%98%B3%E5%85%89%E4%B8%8B%E7%9A%84%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[早上上班路上 中午公司附近]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近看的书记录]]></title>
    <url>%2F2020%2F09%2F13%2F%E6%9C%80%E8%BF%91%E7%9C%8B%E7%9A%84%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[《两京十五日》 马伯庸 历史 《机器之门》 江波 科幻 《机器之魂》江波 科幻 《十九年间谋杀小叙》那多 悬疑 《高堡奇人》菲利普·迪克 科幻 《知日的风景》汪涌豪 社科]]></content>
      <tags>
        <tag>书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《殷商舰队玛雅征服史》]]></title>
    <url>%2F2020%2F08%2F01%2F%E3%80%8A%E6%AE%B7%E5%95%86%E8%88%B0%E9%98%9F%E7%8E%9B%E9%9B%85%E5%BE%81%E6%9C%8D%E5%8F%B2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[这又是一本马伯庸的书，挺搞笑的一本脑洞大开的小说。 第一次听到这本书还是高中某天晚自习结束后被人安利了，当时觉得很有趣，无奈店里没卖，没条件看电子版，也没法网购。 &nbsp; 说起来，我的青春最快乐的事情就是放学后和几人一路扯东扯西。 最近不知怎么又想起了这本书，便买来把它看完了。 书里面的公共关系又荒诞又现实。 书最后的后记笑死我了。]]></content>
      <tags>
        <tag>书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《克苏鲁神话I-II》]]></title>
    <url>%2F2020%2F07%2F25%2F%E3%80%8A%E5%85%8B%E8%8B%8F%E9%B2%81%E7%A5%9E%E8%AF%9DI-II%E3%80%8B%2F</url>
    <content type="text"><![CDATA[今天看完了这本书，H.P.洛夫克拉夫特写的。 作为最经典的克苏鲁小说，我反而没什么感觉，可能是时代的原因吧，没有太大的代入感。 不过还是值得一看。 我们所知的一切渺小又可笑]]></content>
      <tags>
        <tag>书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世博]]></title>
    <url>%2F2020%2F07%2F25%2F%E4%B8%96%E5%8D%9A%2F</url>
    <content type="text"><![CDATA[周六出去走走，去了过去举办世博会的地方。 世博博物馆 这么多国旗，当年一定挺壮观的。 &nbsp; 博物馆的外观挺有意思的 内部楼梯一角 小鸟瓷器 毛子的花标本 中华艺术宫两年前从这里路过，一晃两年过去了。没什么太大的变化，两年前坐着8号线去，今天也是8号线，不同的是，两年前晚上空空的车厢，现在下午人挺多的。]]></content>
      <tags>
        <tag>游历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期看完的书]]></title>
    <url>%2F2020%2F07%2F19%2F%E8%BF%91%E6%9C%9F%E7%9C%8B%E5%AE%8C%E7%9A%84%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[《荒潮》 陈楸帆 类型：科幻 评分：4.9/10 赛博朋克外衣的科幻小说，故事性一般，越到后面越拉垮，另外作者貌似有崇洋媚外的倾向。 《光明王》 罗杰·泽拉兹尼 类型：科幻 评分：6/10 偏向于奇幻的科幻小说，技术的垄断和封锁产生了神与凡人的差距，把剧情和印度教和佛教结合在一起，有点意思。经常模仿史诗风格，阅读过程略显无聊和无趣。 &nbsp; 《万寿寺》王小波 类型：荒诞 评分：7/10 以失忆的“我”的角度写小说，现实的“我”和小说中的“薛嵩”两条线相互交错进行，各种讥讽，很荒诞的展开，尤其是薛嵩线。唯一的缺点就是薛嵩线情节重复或者说写的比较啰嗦，另外这本书不太适合在公共场合看，很多对性的直接描写。长安城里的一切已经结束。一切都在无可挽回地走向庸俗。 《龙与地下铁》马伯庸 类型：奇幻/少年 评分：7/10 没想到亲王还写过这么少年热血风的小说。脑洞很多，飞机大炮与剑修，科技与魔法融合的一点也不违和。少年与龙的友谊。很怀疑亲王是写给世子看的，“成熟“的人大概会看不下去这本书吧。]]></content>
      <tags>
        <tag>书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海的海]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%B8%8A%E6%B5%B7%E7%9A%84%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[一直想去看海。便去了看上海的海，不好看👎。 当站在高处视线越过堤坝的时候看到了一望无际的海，依然感觉心中都辽阔了起来。 1#无法理解那些在那么一小块被围起来的地方游泳的人呢,不觉得压抑憋屈吗，和泳池有什么区别呢 &nbsp;]]></content>
      <tags>
        <tag>游历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云上的天]]></title>
    <url>%2F2020%2F07%2F12%2F%E4%BA%91%E4%B8%8A%E7%9A%84%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[云上的天，很美～ &nbsp; 我会一直记着那天的云。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春与夏]]></title>
    <url>%2F2020%2F05%2F20%2F%E6%98%A5%E4%B8%8E%E5%A4%8F%2F</url>
    <content type="text"><![CDATA[1#谨以此诗送给源源 春天还在的时候你来了 春雨为你停了 带来了金色的阳光 带来了蓝色的天空 带来了棉花一样的云 从未经历过如此明媚的春 &nbsp; 你回家的那天春天走了 夏天带着雨过来了 雨滴落在候机大楼的玻璃上 雨滴落在飞机的舷窗上 雨滴落在地铁的窗户上 雨滴落在我的心里 &nbsp; 初夏的雨终究会结束 我会在深夏阳光灿烂之时见你 明媚的春光与灿烂的夏天 你与我]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咖啡]]></title>
    <url>%2F2020%2F03%2F17%2F%E5%92%96%E5%95%A1%2F</url>
    <content type="text"><![CDATA[咖啡呢 找不到了 我找不到我的咖啡了 它去哪儿了 &nbsp; 我在黄沙里吐息 橘色的精灵在飞舞 翻滚的阳光 远方隐隐绰绰有花，有秋千 &nbsp; 我是迷途的旅者 我向着不可企及的远方前进 我将倒在这黄海中 吞下热辣的野炎 被精灵覆盖 &nbsp; 是夜，我将在最后的梦里 飞向蜃楼 我将在那荡着秋千 喝着花茶 永不醒来]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晨光]]></title>
    <url>%2F2020%2F03%2F07%2F%E6%99%A8%E5%85%89%2F</url>
    <content type="text"><![CDATA[去年9月拍的太阳，现在我好像又看到了一丝光。 &nbsp;]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩虹]]></title>
    <url>%2F2019%2F10%2F01%2F%E5%BD%A9%E8%99%B9%2F</url>
    <content type="text"><![CDATA[国庆下午看到的彩虹。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草地]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%8D%89%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[位于江苏的某片小草地。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方的摩天轮]]></title>
    <url>%2F2019%2F05%2F14%2F%E8%BF%9C%E6%96%B9%E7%9A%84%E6%91%A9%E5%A4%A9%E8%BD%AE%2F</url>
    <content type="text"><![CDATA[夜晚下远方的摩天轮。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孤鸟]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%AD%A4%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[​ 站在电线上发呆的小鸟。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[樱花]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%A8%B1%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[​ 去年的樱花现在又开了，还记得吗？]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清明时节的凌晨]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%B8%85%E6%98%8E%E6%97%B6%E8%8A%82%E7%9A%84%E5%87%8C%E6%99%A8%2F</url>
    <content type="text"><![CDATA[故人从窗边走过 我醒了 黑暗中出现了一片亮光 是墙壁在发出光芒 一扇窗慢慢浮现在墙壁上 &nbsp; 往窗外看去 阴沉的天空 树叶在流浪 模糊的山丘 这是老家的一扇窗 &nbsp; 噼里啪啦 山那边传来鞭炮声 我醒了 心的位置很痛 我推开了大门 两条乡间的小道在面前交汇 &nbsp; 身后传来戏虐的笑声 我无法回头 笑声不断靠近 直到脑海深处 无声的呐喊 &nbsp; 心的位置再次传来痛苦 我醒了 我躺在学校宿舍床上 眼泪滑过脸颊 风夹着鞭炮声 狗一直在叫 这是一个清明时节的凌晨]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[城市地平线]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%9F%8E%E5%B8%82%E5%9C%B0%E5%B9%B3%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[​ 周六醒来后突然想出去走走，一个人去看了《波西米亚狂想曲》，摇滚果然可以让负面情绪得到些许释放，回学校的路上看到了城市的地平线，没有拍出看到的感觉(￣ー￣)]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南宋御街]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%8D%97%E5%AE%8B%E5%BE%A1%E8%A1%97%2F</url>
    <content type="text"><![CDATA[​ 一个人在南宋御街瞎走的时候拍的，人很多，两边的店都很有意思。]]></content>
      <tags>
        <tag>游历</tag>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[江边倒影]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%B1%9F%E8%BE%B9%E5%80%92%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[​ 一张在江边的夜景，做了些许后期处理。想起了一句话”莫把湖面倒影当作夜空繁星”，出处好像来自于《巫师》。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火车与蝉]]></title>
    <url>%2F2019%2F03%2F16%2F%E7%81%AB%E8%BD%A6%E4%B8%8E%E8%9D%89%2F</url>
    <content type="text"><![CDATA[我在摇晃的巴士上与你交谈 洁白的上衣 轻轻上扬的嘴角 几根凌乱的发丝 时间仿佛静止了&nbsp; 一股寒意突然降临 我看见所有人冷冷的看向我 你在冷笑 我在逃跑，漫无目的的跑 没有一丝光的黑暗追着我&nbsp; 前面出现了火车站 我看见你的背影在安检 我推开了所有人冲向了站内 一列火车鸣着笛冲向了我 我听见了蝉鸣的声音 火车呼啸而过]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西湖]]></title>
    <url>%2F2019%2F03%2F14%2F%E8%A5%BF%E6%B9%96%2F</url>
    <content type="text"><![CDATA[​ 这张照片是我在西湖拍的照片中最好的一张。]]></content>
      <tags>
        <tag>游历</tag>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鲁迅故居]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%B2%81%E8%BF%85%E6%95%85%E5%B1%85%2F</url>
    <content type="text"><![CDATA[​ 去年在上海看完miku演唱会的第二天，不知怎么的突然想去看鲁迅居住过的地方，选了个没有被开发的地方便出发了，作为路痴我迷失在那边的弄堂里，绕来绕去绕了很久，最后还是住在附近的大爷给我指了路。。。 ​ 鲁迅住在一条巷子的尽头，门前的花草很茂盛，大概还有人在打理吧。]]></content>
      <tags>
        <tag>游历</tag>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富士山杯]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%AF%8C%E5%A3%AB%E5%B1%B1%E6%9D%AF%2F</url>
    <content type="text"><![CDATA[昨天买了一个富士山造型的水杯，感觉挺好看的，倒了可乐后就像夕阳一样，突然想起了《摇曳露营》。]]></content>
      <tags>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明月与太阳]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%98%8E%E6%9C%88%E4%B8%8E%E5%A4%AA%E9%98%B3%2F</url>
    <content type="text"><![CDATA[我看见一只蝴蝶 它朝着大海飞去 阳光穿透翅膀 放出灼人的色彩 它与太阳一同坠落在大海 &nbsp; 明月于海的尽头升起 深海鱼冲破了水面 我看见成群的鱼在天上飞 月光倾洒在它们身上 洁白的鱼肚发出柔和的白光 &nbsp; 明月消灭了夜 太阳消灭了我]]></content>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
</search>
